영상: https://www.youtube.com/playlist?list=PLD8rdlfZeJk6evHY9NsnBqXKrreNbTqFv

# 알고리즘과 그래프



## 1. 알고리즘

- 문제를 해결하기 위한 절차를 기술한 것
- 누구나 정해진 절차대로 실행할 수 있어야 한다.
- 누구나 동일한 입력값이 주어지면 이 절차대로 실행하면 동일한 출력값을 얻을 수 있어야 한다.
- 일정한 시간안에 출력값을 구할 수 있어야 한다.



Formal하게 정의해보면

- 순서대로 정의된 절차
  - 분명한 순서가 있어야 한다.
  - 한 동작을 실행하면 다음에 실행할 동작이 무엇인지 분명해야 한다.
- 명확성
  - 모든 동작은 명확하게 정의되어야 한다.
  - 모든 동작은 실행 가능해야 한다.
- 반드시 원하는 결과가 나와야 한다.
- 일정한 시간안에 실행되어야 한다.



### 알고리즘 기술 방법

1. 플로우차트
2. 프로그램 언어의 코드
   - 이것을 특정 프로그램 언어의 문법을 알아야 한다.
   - 또 코드 수준으로 자세히 적을 필요는 없다.
3. Pseudocode (수도코드)
   - 프로그램 언어의 코드 전 단계로 프로그램 언어들이 사용하는 구조를 그대로 이용한다.





## 2. 오일러 순환과 해밀턴 순환

### 오일러 경로 or 한 줄로 그리기 문제 (한붓 그리기)

### ![image-20210711223436399](알고리즘,그래프.assets/image-20210711223436399.png)



### 차수

정점 u에 접합된 연결선의 수, 차수는 `deg(u)`와 같이 표기하기도 한다.

### 오일러 경로의 시작점, 중간정점, 끝점

- 시작점
  - 나가야 하기 때문에 시작점의 차수는 홀수여야 한다.
- 중간정점
  - 중간정점은 들어왔다가 나가야하므로 중간정점의 차수는 반드시 짝수여야 한다.
  - 홀수라치면 들어왔다가 나갔다가 다시 들어오면 나갈수가 없기 때문에 끝점이 될 수 밖에 없다.
- 끝점
  - 마지막으로 들어와야 하기 때문에 끝점의 차수는 홀수여야 한다.

![image-20210711224517914](알고리즘,그래프.assets/image-20210711224517914.png)



### 오일러 경로의 알고리즘 복잡도

n개의 차수를 다 고려해보고 홀수가 2개인지를 찾으면 된다.

n * 차수 <= n*(n-1) <= n<sup>2</sup>







### 해밀턴 경로, 해밀턴 순환

> 해밀턴 경로: 그래프 G에서 모든 정점을 정확히 한 번만 지나는 경로 (연결선이 아니고 정점을 한번만)
>
> 해밀턴 순환: 시작점과 끝점이 같은 해밀턴 경로



#### 시간복잡도

해밀턴 경로의 경우 알고리즘이 딱히 존재하기 않기 때문에 모든 방법을 다 해보는 브루트포스 알고리즘이다.



### 방문 판매원 문제

- 연결선에는 비용이 주어진다.
- 일반적으로 완전 그래프
- 이 그래프에서 비용이 최소가 되는 해밀턴 순환을 찾는 문제
- Exhaustive search







## 3. 그래프 기본 용어

> 그래프 G는 다음의 두 가지 집합으로 구성되며 `G = {V,E}`로 표시한다. 여기서 V는 `정점`(vertex)들의 집합이며, E는 정점들을 연결하는 `간선`(edge)들의 집합이다.

![image-20210712013039197](알고리즘,그래프.assets/image-20210712013039197.png)



> 두 정점 u와 v사이에 연결선이 존재하면 두 정점은 열결되었다고 한다.



- 길이: 두 정점의 경로를 구성하는 연결의 수
- 거리: 두 정점간의 최단 경로의 길이
- 닫힌 경로: 만약 경로에서 v1 = vn인 경로
- 순환: 3개 이상의 연결선을 갖는 경로에서 어떤 연결선도 중복되지 않는 닫힌 경로





### 동형 그래프

![image-20210712013325328](알고리즘,그래프.assets/image-20210712013325328.png)

### 완전 그래프

그래프 G가 모든 정점 사이에 연결선이 존재하면 G를 완전 그래프라고 한다. 완전 그래프틑 Km으로 표시한다. (m은 정점의 총 수)



### 이분 그래프

![image-20210712013438575](알고리즘,그래프.assets/image-20210712013438575.png)



### 평면 그래프

![image-20210712013517468](알고리즘,그래프.assets/image-20210712013517468.png)





### 방향 그래프

그래프 G에서 연결선의 두 정점이 순서쌍일 때 G를 방향 그래프라고 한다.





## 4. 그래프 채색

> 그래프의 채색: 인접하고 있는 정점들은 서로 다른 색을 갖도록 하면서 그래프의 모든 정점에 색을 할당
>
> 색상수: 그래프 채색에 필요한 최소한의 색의 수 x(G)로 표시한다.

![image-20210712234911544](알고리즘,그래프.assets/image-20210712234911544.png)



### Greedy Algorithm

결정을 할 때 마다 최종 결과에 관계없이 그 순간에서 최선의 선택을 한다.

그 순간의 선택은 구 순간에서 최적의 선택이다. (locally optimal solution)

하지만, 최종의 결과가 최적이라는 보장은 없다. (global optimal solution)





## 5. 최소신장 트리 (MST : Minimum Spanning Tree)

### 이 부분 부터는 태희쌤 강의 다시듣는 것 추천



> 신장트리: 그래프 G={V,E}에서 V의 모든 정점을 포함하면서 순환이 존재하지 않는 부분 그래프를 신장트리라고 한다.
>
> 최소신장트리: 가중그래프에서 가중치의 합을 최소로하는 신장트리를 최소신장 트리라고 한다. EX) Prim 알고리즘, Kruskal 알고리즘



### Prim 알고리즘

- Greedy 알고리즘

- 하지만, Prim 알고리즘은 모든 그래프에 대해서 최적의 해를 구한다.

- 증명은 다음과 같이 간단히 할 수 있다.



![image-20210713003513384](알고리즘,그래프.assets/image-20210713003513384.png)

1. G의 부분그래프 G1, G2가 있다고 하자.

   G1은 MST라고 하자. 그리고 연결선 e를 G1과 G2를 가로지르는 연결선이라고 하자.

2. (가정) 만약 G의 MST에 e가 포함되지 않는다고 하자.
3. 이 MST에 e를 추가하면 순환이 된다.
4. 이 순환 그래프에는 G1과 G2의 crossing Edge가 e이외에 또 존재하며 이것을 f라고 하자.
5. 순환 그래프에서 f를 제거하면 e를 포함한 MST가 된다.
6. 이렇게 만들어진 G의 MST는 원래 MST보다 더 적은 비용의 MST가 된다.
7. 따라서 단계2에서 가정한 것이 모순이 된다.
8. 결국 G의 MST는 e를 포함해야 한다.
9. 따라서 Prim의 알고리즘에서 첫 번째 정점에서 부터 반복된 절차로 선택된 e로 구성된 MST는 G의 최소비용의 MST가 된다.



시간복잡도: V * logE



### Kruskal MST 알고리즘

> 입력: 그래프 =  {V,E}
>
> 출력: 최소신장트리



1. E의 모든 연결설을 비용이 적은 순서대로 정렬한다.

2. while(T의 연결선의 수 < V의 정점의 수 - 1)
   - 순서대로 정렬된 E의 연결선 중에서 차례대로 (u,v)를 선택한다.
   - 이때, (u,v)는 T에 속한 연결선과 순환을 만들지 않는 것이어야 한다.





시간복잡도: E * logE





## 6. 최단경로 알고리즘

- 다익스트라 알고리즘
- Bellman-Ford 알고리즘





